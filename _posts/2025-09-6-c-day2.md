---
title: Secure Programming in C – Day 2; Windows Tokens, SIDs, and How Restrictions Work
date: 2079-09-6 11:24:00 +/-TTTT
image:
  path: assets/img/favicons/https___dev-to-uploads.s3.amazonaws.com_uploads_articles_c5w3ejsemo38r6fbhhzi.webp
  class: "img-right"
categories: [CyberSecurity]
tags: [Low-level, Programming]  
---



# Intro

When you start programming in C on Windows, understanding how the operating system controls access is just as important as learning pointers, memory, or arrays. Unlike Unix, where permissions mostly depend on user IDs and group IDs, Windows has a **detailed security system** built around tokens, SIDs, privileges, and ACLs (Access Control Lists). Every process or thread has a token that represents its **security context**, and every object, files, registry keys, processes, has rules about who can access it. If you misunderstand or misuse tokens and privileges, your program may have serious vulnerabilities like local privilege escalation or unauthorized access to sensitive resources.

In this article, we’ll go step by step, from basics to internals, then to common vulnerabilities, and finally to defensive programming. Along the way, I’ll include ASCII diagrams and C API examples so you can try things safely and understand how Windows privilege models actually work.

### Basics: Tokens and SIDs

At the core of Windows security is the **access token**. You can think of a token like a **passport for a process**. It tells Windows:

* Who owns the process
* What groups the owner belongs to
* What special privileges the process has
* Whether it can impersonate another user

Each user or group in Windows has a **SID (Security Identifier)**. A SID is not just a number; it is a structured, globally unique identifier. For example, `S-1-5-21-1234567890-123456789-123456789-1001` could represent a specific user. When your process tries to open a file, registry key, or another process, Windows compares the SIDs in your token with the SIDs listed in the object’s ACL.

Privileges are **special rights** assigned to the token. Examples include:

* `SeDebugPrivilege` – allows reading and modifying other processes
* `SeBackupPrivilege` – allows reading files even if ACLs deny access
* `SeRestorePrivilege` – allows writing files ignoring ACLs

Tokens also have a **type** (primary or impersonation) and an **impersonation level**, which defines what the process can do if it is pretending to be another user.

***

<figure><img src="https://4146235939-files.gitbook.io/~/files/v0/b/gitbook-x-prod.appspot.com/o/spaces%2FVsJVX5kOfAZOe1840NhZ%2Fuploads%2FAU18ydfY1z94S34DD6ZL%2Fimage.png?alt=media&#x26;token=4fbe839c-a5f4-4967-a78c-7bf35385baaa" alt=""><figcaption></figcaption></figure>

Each process inherits a token from its parent. For example, services started by SYSTEM will have a **system token**, while a normal program started by a standard user will have a **user token**.

***

### Internals: How Windows Uses Tokens

When your process tries to access a file, registry key, or another object, Windows uses **access checks**:

1. Retrieve the object’s security descriptor, which contains:
   * Owner SID
   * DACL (Discretionary Access Control List) – defines who can access the object
   * SACL (System Access Control List) – used for auditing
2. Compare the process token’s UserSID and GroupSIDs against the DACL
3. Check privileges in the token that might allow bypassing certain restrictions
4. Grant or deny access

For example, opening a file in C:

```c
HANDLE file = CreateFile(
    "C:\\secret.txt",
    GENERIC_READ,
    0,
    NULL,
    OPEN_EXISTING,
    FILE_ATTRIBUTE_NORMAL,
    NULL
);
```

Windows evaluates your process token: if your SIDs match an ACL entry granting `GENERIC_READ`, you get the handle. If your token has `SeBackupPrivilege`, you can read files even if the DACL normally denies access.

<figure><img src="https://4146235939-files.gitbook.io/~/files/v0/b/gitbook-x-prod.appspot.com/o/spaces%2FVsJVX5kOfAZOe1840NhZ%2Fuploads%2F10w1kwvi2QaYSgY2sdlU%2Fimage.png?alt=media&#x26;token=7576c3e2-bbbb-4b23-a064-b1d154c66a46" alt=""><figcaption></figcaption></figure>

### Vulnerabilities: Mismanaged Tokens and Privileges

Many vulnerabilities happen when programmers **misunderstand or misuse tokens**. Some examples:

* **Assuming admin rights:** If your program assumes the user can access sensitive files, it might crash or allow unauthorized access when run as a standard user.
* **Improper token duplication:** Using `DuplicateTokenEx()` without restricting privileges may give child processes **more authority than intended**. A local attacker can exploit this to escalate privileges.
* **Ignoring SACLs or auditing rules:** Your program may bypass logging, hiding sensitive actions.
* **Over-permissive ACLs:** Creating files, keys, or objects with ACLs granting Everyone full control is a backdoor waiting to be exploited.

**Example of Vulnerable Token Duplication**

```c
HANDLE dupToken;
OpenProcessToken(GetCurrentProcess(), TOKEN_ALL_ACCESS, &dupToken);
// Duplicate token and create a child process
```

If the duplicated token contains all privileges of the parent, the child process can do **anything**, including administrative tasks, even if the user is standard.

Privilege escalation through `SeDebugPrivilege` is especially dangerous: a process with this privilege can attach to other processes, read/write memory, inject code, or bypass security checks.

<figure><img src="https://4146235939-files.gitbook.io/~/files/v0/b/gitbook-x-prod.appspot.com/o/spaces%2FVsJVX5kOfAZOe1840NhZ%2Fuploads%2FpTk5SRlyiy4GbRvhaonH%2Fimage.png?alt=media&#x26;token=0dcc9f35-d572-4e98-acdd-2a116bd3c310" alt=""><figcaption></figcaption></figure>

### Defensive Programming in C

Writing secure Windows programs means **inspecting tokens, applying least privilege, and managing ACLs carefully**. Some important steps:

* **Inspect tokens:** Use `OpenProcessToken()` and `GetTokenInformation()` to check the user, groups, and privileges before sensitive operations.
* **Check privileges:** Don’t assume your process can do anything. Verify with the token.
* **Use least privilege:** Create child processes with **only necessary privileges**, disabling any unneeded ones.
* **Secure object creation:** Explicitly set ACLs when creating files, keys, or other objects. Avoid defaults that are too open.
* **Close handles:** Prevent token leaks that could be abused later.
* **AdjustTokenPrivileges:** Enable or disable privileges safely before creating child processes.

**Example: Creating a Restricted Child Process Safely**

```c
STARTUPINFO si = {0};
PROCESS_INFORMATION pi = {0};
HANDLE restrictedToken;

OpenProcessToken(GetCurrentProcess(), TOKEN_DUPLICATE | TOKEN_QUERY, &restrictedToken);
DuplicateTokenEx(restrictedToken,
                 MAXIMUM_ALLOWED,
                 NULL,
                 SecurityIdentification,
                 TokenPrimary,
                 &restrictedToken);

// Disable unnecessary privileges
// AdjustTokenPrivileges(restrictedToken, ...);

CreateProcessAsUser(restrictedToken,
                    "C:\\program.exe",
                    NULL,
                    NULL,
                    NULL,
                    FALSE,
                    0,
                    NULL,
                    NULL,
                    &si,
                    &pi);

CloseHandle(restrictedToken);



```

This piece of code shows how a Windows program can **create a new process with restricted privileges**, instead of just giving it full rights like the current program has. In Windows, every running program has a **token**, which is like a badge that says who the user is, which groups they belong to, and what special powers (privileges) the program has. For example, some programs might have the power to shut down the system, read any file, or debug other processes. If a program runs as an administrator or SYSTEM, giving all these powers to another program can be dangerous. That’s why we sometimes want to **duplicate the token** and remove some of its powers before creating a new process.

The first two lines,

```c
STARTUPINFO si = {0};
PROCESS_INFORMATION pi = {0};
```

create structures that Windows needs to store information about the new process. `STARTUPINFO` holds settings like the window size or appearance of the process, and `PROCESS_INFORMATION` will hold handles and IDs for the process after it is created.

Next,

```c
OpenProcessToken(GetCurrentProcess(), TOKEN_DUPLICATE | TOKEN_QUERY, &restrictedToken);
```

grabs the token of the current process. `TOKEN_DUPLICATE` allows us to make a copy, and `TOKEN_QUERY` lets us read information about it.

```c
DuplicateTokenEx(restrictedToken,
                 MAXIMUM_ALLOWED,
                 NULL,
                 SecurityIdentification,
                 TokenPrimary,
                 &restrictedToken);
```

makes a **new token** based on the original one. This new token is “primary,” meaning it can be used to start a new process. The `SecurityIdentification` part sets the level for impersonation, which controls how the process can act as another user. After this, we could call `AdjustTokenPrivileges` to **disable any extra privileges** we don’t want the new process to have, like shutting down the computer or debugging other processes. This makes the new process safer to run.

Then,

```c
CreateProcessAsUser(restrictedToken,
                    "C:\\program.exe",
                    NULL,
                    NULL,
                    NULL,
                    FALSE,
                    0,
                    NULL,
                    NULL,
                    &si,
                    &pi);
```

actually creates the new process using the restricted token. This tells Windows: “Start `program.exe`, but only give it the powers in this token, not all the powers my program has.” This is a key step in **least-privilege programming**, which prevents accidental or malicious damage by limiting what a new process can do.

Finally,

```c
CloseHandle(restrictedToken);
```

closes the token handle to free system resources. If we didn’t do this, Windows would keep that token in memory, which could cause leaks or security issues.

In simple terms, this code is about **creating a safer, limited process** in Windows by copying your current security context, removing dangerous privileges, and starting a program that can’t do everything your main program can. It’s a common technique when you want to run third-party software, scripts, or tasks without risking full access to the system.

See You In Day 3!

***

## References

1. Microsoft Learn. (n.d.). *Access Tokens - Win32 apps*. Available at: [https://learn.microsoft.com/en-us/windows/win32/secauthz/access-tokens](https://learn.microsoft.com/en-us/windows/win32/secauthz/access-tokens)

2. MITRE ATT&CK®. (n.d.). *T1134: Access Token Manipulation*. Available at: [https://attack.mitre.org/techniques/T1134/](https://attack.mitre.org/techniques/T1134/)

3. Microsoft Learn. (n.d.). *Well-known SIDs*. Available at: [https://learn.microsoft.com/en-us/windows/win32/secauthz/well-known-sids](https://learn.microsoft.com/en-us/windows/win32/secauthz/well-known-sids)

4. Red Canary. (2021). *Better Know a Data Source: Access Tokens*. Available at: [https://redcanary.com/blog/threat-detection/better-know-a-data-source/access-tokens/](https://redcanary.com/blog/threat-detection/better-know-a-data-source/access-tokens/)

