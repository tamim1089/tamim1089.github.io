---
title: Secure Programming in C – Day 1; Taming Unix Environment Variables
date: 2025-09-2 13:54:00 +/-TTTT
image:
  path: assets/img/favicons/https___dev-to-uploads.s3.amazonaws.com_uploads_articles_c5w3ejsemo38r6fbhhzi.webp
  class: "img-right"
categories: [CyberSecurity]
tags: [Low-level, Programming]  
---

When you write C programs on Unix, environment variables are something you usually don’t think about, but they exist in memory the moment your program starts. Every process receives strings like `HOME=/home/alex` or `PATH=/usr/bin:/bin` from the OS. You don’t type them, and they’re not in your source code, but they live near your stack and program arguments. Because of that, they can become dangerous if your program handles them carelessly.

Environment variables are essentially external input that the OS gives you automatically. Any variable can be long, malformed, or maliciously crafted. If you copy it into a fixed-size buffer without checking, you can overwrite memory that wasn’t meant to be touched. Understanding how these variables are stored and accessed in memory is key to writing secure C code.

Think of environment variables as **little notes the operating system gives your program** before it starts. For example:

```bash
echo $PATH
```

prints something like:

```
/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin
```

That’s your shell telling programs: “Hey, when you need to find an executable, look here.” Other variables might include `HOME`, `USER`, `LANG`, or custom stuff like `MY_SECRET_KEY`.

### Accessing Environment Variables

You can access environment variables using `getenv()`:

```c
#include <stdio.h>
#include <stdlib.h>

int main() {
    char *user = getenv("USER_INPUT"); // fetch variable from OS
    if(user) {
        printf("USER_INPUT = %s\n", user); // display what OS gave us
    }
    return 0;
}
```

Or iterate through all of them using `envp`:

```c
int main(int argc, char *argv[], char *envp[]) {
    for(int i = 0; envp[i] != NULL; i++)
        printf("%s\n", envp[i]);
}
```

Both methods give access to the same memory, meaning if an attacker puts a huge string in an environment variable, it can overwrite nearby memory if your program isn’t careful. You can imagine that `envp` is like a map to every string the OS pushed into your process, and it sits right in memory your local variables will occupy.

### How Environment Variables Sit in Memory

When a program starts, the OS sets up `argc`, `argv`, and `envp` on the stack. The conceptual stack layout looks like this:

<figure><img src="https://4146235939-files.gitbook.io/~/files/v0/b/gitbook-x-prod.appspot.com/o/spaces%2FVsJVX5kOfAZOe1840NhZ%2Fuploads%2F3PnlhiohNkOWFY3RJNHS%2Fimage.png?alt=media&#x26;token=d7a8c31a-d68b-4e4a-854f-25483e17a832" alt=""><figcaption></figcaption></figure>

Notice that envp strings are above your local variables. If you blindly copy them into a buffer, they can overwrite your buffer and spill into saved frame pointer and return address.

<figure><img src="https://4146235939-files.gitbook.io/~/files/v0/b/gitbook-x-prod.appspot.com/o/spaces%2FVsJVX5kOfAZOe1840NhZ%2Fuploads%2FMaVsiYvPpzVWfx5Encj2%2Fimage.png?alt=media&#x26;token=00f69003-402f-42e1-92ec-76e7806b2052" alt=""><figcaption></figcaption></figure>

A long string in `USER_INPUT` can overwrite the return address, leading to crashes or even code execution if protections are missing.

## Vulnerability Example

Here’s a vulnerable program:

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

int main() {
    char buffer[64];
    char *user = getenv("USER_INPUT");

    // unsafe copy: can overflow buffer
    strcpy(buffer, user);

    printf("Hello %s\n", buffer);
    return 0;
}
```

If `USER_INPUT` is longer than 64 bytes:

```bash
export USER_INPUT=$(python3 -c "print('A'*100)")
./vulnerable_program
```

Without stack canaries, NX, or ASLR, this can allow an attacker to control program flow. Even with protections, the program may crash, which is still a serious security issue.

#### Special Environment Variables

Some variables are extra risky. `LD_PRELOAD` allows loading shared libraries before system libraries. If not sanitized, critical functions like `open()` or `exec()` can be replaced by malicious code. `PATH` can be manipulated to execute a malicious binary instead of the intended one. Custom variables like `USER_INPUT` or `CONFIG_PATH` can be exploited if your program assumes they are safe.

## Memory Risk

Stack example:

<figure><img src="https://4146235939-files.gitbook.io/~/files/v0/b/gitbook-x-prod.appspot.com/o/spaces%2FVsJVX5kOfAZOe1840NhZ%2Fuploads%2FLbvyMAeQHpo9JJRnIDyn%2Fimage.png?alt=media&#x26;token=cf641371-c38f-4fa4-89bc-584564f8def7" alt=""><figcaption></figcaption></figure>

Copying a long string into buffer writes upward, smashing the frame pointer and return address. Environment variables are hidden attack vectors.

## Safe Handling

Environment variables should always be treated as **untrusted input**. They can be extremely long, malformed, or even deliberately crafted to break your program. If you copy them into fixed-size buffers without checks, you’re giving attackers a direct line to corrupt memory.

### Bounded Copies

The most common mistake is using `strcpy()` or similar functions that copy without checking length. A safer pattern is to only copy what fits in your buffer, and then explicitly terminate the string:

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

int main() {
    char buffer[64];
    char *user = getenv("USER_INPUT");

    if(user) {
        strncpy(buffer, user, sizeof(buffer) - 1);
        buffer[sizeof(buffer) - 1] = '\0'; // ensure termination
    }

    printf("Safe Hello: %s\n", buffer);
    return 0;
}
```

`strncpy` has quirks, so you must always force the null terminator yourself. On systems that provide it, `strlcpy()` or even `snprintf()` are cleaner choices:

```c
snprintf(buffer, sizeof(buffer), "%s", user);
```

### Sanitizing Dangerous Variables

Some environment variables are more dangerous than others. Variables like `LD_PRELOAD`, `LD_LIBRARY_PATH`, and `PATH` control how the loader or shell behaves. In privileged programs, it’s safer to clear them:

```c
unsetenv("LD_PRELOAD");
unsetenv("LD_LIBRARY_PATH");
unsetenv("PATH");
unsetenv("IFS");
```

You can also rebuild the environment from scratch and only keep the variables you explicitly allow.

### Dynamic Allocation

If you don’t know how big the input will be, a fixed buffer is a bad idea. Allocating memory dynamically avoids stack overflow:

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

int main() {
    char *user = getenv("USER_INPUT");
    if(user) {
        size_t len = strlen(user) + 1;
        char *buffer = malloc(len);
        if(buffer) {
            memcpy(buffer, user, len);
            printf("Hello %s\n", buffer);
            free(buffer);
        }
    }
    return 0;
}
```

Heap allocation doesn’t magically make input safe, but it does remove the risk of smashing your stack. You still need to validate the length and content, and always free the memory when done.

See you in Day 2!
