[
  
  {
    "title": "BufferOverflow for Skids - Part I",
    "url": "/posts/bufferoverflow-for-skids-part-1/",
    "categories": "CyberSecurity",
    "tags": "lowlevelprogramming, bof, securecoding",
    "date": "2025-03-19 14:54:00 +0400",
    





    
    "snippet": "Alright, so you’re still stuck on this ridiculously basic buffer overflow stuff? Fine. Let’s do this one more time, and try to keep up.A buffer is just a tiny storage box in your computer’s brain t...",
    "content": "Alright, so you’re still stuck on this ridiculously basic buffer overflow stuff? Fine. Let’s do this one more time, and try to keep up.A buffer is just a tiny storage box in your computer’s brain that holds some temporary data. Now, a buffer overflow happens when some psychopath tries to stuff way too much data into that box, and it spills out everywhere. Think of pouring a gallon of soda into a shot glass. What happens? It overflows and makes a mess. And where does this mess land? On important parts of memory that tell your computer what to do next.One key piece it can mess up is the return address basically, a sticky note on the computer’s to-do list that says, “Hey, after you finish this task, go here next.” This note lives on the stack, which is just a set of instructions stacked on top of each other. Overflow that buffer, and boom you knock the stack over, scratch all over those sticky notes, and suddenly the computer is taking orders from you instead. Badass, right?Now, to actually hijack a program, you need to know exactly how much extra garbage data (or ‘padding’) you need to reach that return address. This is called finding the offset. The usual way? Just keep throwing junk at the program until it crashes and tells you exactly where things went wrong.Now, let’s talk about the heap. Heap is a big, messy storage room where your computer keeps track of dynamic memory stuff that can grow and shrink as needed. When you ask for memory, the heap gives you a chunk, but if you’re not careful and you overflow a buffer here, you can overwrite other important data stored in the heap.And just like the stack, the heap has its own set of rules and structures. If you mess with the heap, you can corrupt pointers those little arrows that tell the computer where to find things. If you change a pointer’s direction, you could make it point to a place it shouldn’t, leading to all sorts of chaos.But wait, modern computers have some security tricks up their sleeves, like NX (No-Execute) and DEP (Data Execution Prevention). These try to stop your plans by blocking certain areas of memory from running code. Annoying, but not unbeatable.Enter Return-to-Libc (R2L) attack;Instead of injecting new code, you just hijack existing functions the program already trusts. By hijacking these trusted functions, we can execute arbitrary commands without the need for injecting new code. This method is particularly effective because it often bypasses security mechanisms designed to detect and block code injection, as the program is simply executing its own trusted functions. Since these functions are already part of the program’s environment, they are less likely to raise suspicion. So we can leverage this trust to perform malicious actions, such as spawning a shell or manipulating data, all while appearing to operate within the normal limits of the program’s functionality.And because nothing in computer science is ever simple, we have endianness a fancy word for “sometimes computers store numbers backward for no good reason.” So when you’re writing an exploit, you might have to flip memory addresses like a dyslexic hacker just to get them to work. (More to cover in Part II)Alright, enough talk; time for some action. Here’s some code that even your dog could understand.The “Safe” Version:#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;unistd.h&gt;void secure() {    char buffer[200];    read(0, buffer, 200); // safe. no stupid mistakes here    printf(\"you entered: %s\\n\", buffer);    printf(\"L=length: %lu\\n\", strlen(buffer));}int main() {    secure();    return 0;}  Let’s run this code for the fcuk sake :elliot@matrix:~/lab$ gcc safe.c -o safe elliot@matrix:~/lab$ printf 'A%.0s' {1..400} | ./safe you entered: AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAApoL=length: 206Nothing exciting. No explosions, No Nuclear bombs dropping from the sky. Just a normal, well-behaved program. Now, let’s get reckless.The “Oops, I Broke the Computer” Version:#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;unistd.h&gt; // disable specific warnings for demonstration purposes#pragma GCC diagnostic push#pragma GCC diagnostic ignored \"-Wstringop-overflow\"void insecure() {    char buffer[200];    (void)read(0, buffer, 400); // that’s 200 bytes too many!    printf(\"you entered: %s\\n\", buffer);    printf(\"length: %lu\\n\", strlen(buffer));}#pragma GCC diagnostic popint main() {    insecure();    return 0;}  Let’s run this code :elliot@matrix:~/lab$ gcc oops-break-bed-not-computers.c -o oopselliot@matrix:~/lab$ printf 'A%.0s' {1..400} | ./oops you entered: AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA�^;�Ulength: 406Segmentation fault (core dumped)Here, we’re trying to stuff 400 bytes into a space meant for 200. The extra junk spills over and starts stepping on important memory. Next thing you know, your program is running wherever you tell it to. That’s how buffer overflow exploits are born.The “Let’s Ruin This Program on Purpose” Version:#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt; // disable specific warnings on modern compilers for demonstration purposes#pragma GCC diagnostic push#pragma GCC diagnostic ignored \"-Wstringop-overflow\"void hackme() {    system(\"ls &gt; hacked.txt\");}int main() {    char buffer[200];    read(0, buffer, 250); // guess what? another overflow    printf(\"you entered: %s\\n\", buffer);            return 0; }#pragma GCC diagnostic pop  Let’s run this code:elliot@matrix:~/lab$ gcc ruin-and-get-rce.c -o ruin-get-rce elliot@matrix:~/lab$ printf 'A%.0s' {1..400} | ./ruin-get-rce you entered: AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAASegmentation fault (core dumped)  In this code, hackme() is never actually called… unless you overflow the buffer and overwrite the return address to point straight at it. Now, instead of doing what it’s supposed to, the program jumps to hackme() and runs system(\"ls &gt; hacked.txt\"), creating a file with a list of everything in the directory. Again, More to cover in Part IIThe “This is Just Asking for Trouble” Code:#include &lt;stdio.h&gt;#include &lt;string.h&gt;int main(int argc, char **argv) {    char buffer[500];    strcpy(buffer, argv[1]); // no safety checks instant disaster    return 0;}Output:elliot@matrix:~/lab$ gcc trouble.c -o troubleelliot@matrix:~/lab$ printf 'A%.0s' {1..100} | ./trouble Segmentation fault (core dumped)elliot@matrix:~/lab$ printf 'A%.0s' {1..501} | ./trouble Segmentation fault (core dumped)This beauty doesn’t even pretend to be safe. It takes whatever input you throw at it, no matter how long, and blindly copies it into buffer. If you give it more than 500 characters, it will happily overwrite important memory, including the return address. And just like that, you control where the program jumps next.So there you have it. Overflowing buffers is like tricking a GPS into driving you straight to your own house instead of its intended destination. It’s a dumb mistake, but one that gives hackers the keys to the kingdom. Now go forth, and for the love of everything holy, stop writing insecure code like this.  Stay tuned for the Part II, where we’ll dive much deeper into the topics we’ve covered and explore more advanced concepts. Get ready for some hands-on experiments and insights that will take your understanding to the next level!"
  },
  
  {
    "title": "What it takes to be an APT",
    "url": "/posts/what-it-takes-to-be-an-apt/",
    "categories": "CyberSecurity",
    "tags": "apt",
    "date": "2025-03-09 09:17:00 +0400",
    





    
    "snippet": "So, You Wanna Be an APT Hacker? A Look Behind the CurtainThinking about stepping into the world of Advanced Persistent Threats (APT)? Not just some amateur messing around with Kali Linux, but the k...",
    "content": "So, You Wanna Be an APT Hacker? A Look Behind the CurtainThinking about stepping into the world of Advanced Persistent Threats (APT)? Not just some amateur messing around with Kali Linux, but the kind of hacker that makes governments nervous and corporations scramble? Well, strap in—because this isn’t just a hobby, it’s a lifestyle. Being an APT hacker isn’t just about knowing your way around code; it’s a mix of patience, obsession, and a deep understanding of how people and systems work. Let’s break it down.The Puzzle Addiction: More Than Just CodeAPT hackers don’t go for easy wins. They treat cybersecurity like a high-stakes chess game, thinking 20 moves ahead while everyone else is stuck at checkers. It’s about peeling back layers finding that one flaw everyone else missed.Take Stuxnet, for example. This wasn’t just some random virus it was a surgical strike on Iran’s nuclear program. Hackers didn’t just throw malware at a system and hope for the best. They studied industrial control systems, identified zero-day vulnerabilities, and crafted a worm that physically sabotaged centrifuges all while feeding fake data to operators. That’s not hacking, that’s genius art.Want to play at that level? You’d better be ready to lose sleep over low-level programming, hardware traits, and obscure software manuals. This game isn’t for the easily distracted lazy asses with ADHD.Patience: The Ultimate WeaponIf you give up when your Wi-Fi lags, APT life isn’t for you. The “P” in APT stands for Persistent for a reason. These hackers can sit inside a system for months, even years, waiting for the right moment.Look at the 2015 Office of Personnel Management (OPM) breach. Hackers, believed to be linked to China, infiltrated U.S. government systems and quietly exfiltrated 21 million personnel records including security clearance data. They didn’t smash through firewalls, they slipped in with stolen credentials and just… waited.Being an APT hacker means accepting the long game. You’re crafting phishing emails so convincing that even security pros fall for them (yes, ashley… i’m talking about you!). You’re setting up c2 servers hidden behind layers of proxies. You’re watching network traffic for weeks, looking for that one weak point. It’s not a Hollywood compilation with htop and cmatrix it’s hours of quiet, careful work.The Tech Arsenal: More Than Just ToolsAPT hackers don’t just rely on off-the-shelf tools. Sure, you might start with Nmap for network scans or BurpSuite for web vulnerabilities, but the real power comes when you go custom.Ever heard of Cobalt Strike? It’s a legitimate pentesting tool that APT groups repurpose for attacks. They drop a tiny payload a beacon onto a target machine. That beacon can stay hidden for months, waiting to exfiltrate data or move laterally through the network.To play in this league, you need to master:  Networking: Understand DNS, TCP vs. UDP, and how to blend into normal traffic.  Programming: Python, C, or Go for malware development. Shellcode for exploits.  Exploitation: Buffer overflows, return-oriented programming (ROP), and bypassing modern security defenses.The 2020 SolarWinds attack? That was a masterclass in APT methodology. Hackers injected malicious code into a trusted software update, letting them slip past defenses unnoticed. To pull something like that off, you’d need deep knowledge of software supply chains and digital forensics. This isn’t beginner area.Social Engineering: Hacking People, Not Just MachinesHere’s a secret: APTs don’t always need fancy exploits. Sometimes, they just need to trick the right person.The 2016 DNC hack? Fancy Bear (a Russian APT group) sent out perfectly crafted phishing emails. They looked real down to the branding and minor typos so staffers clicked without a second thought. Once they had a foothold, it was game over.To be an APT hacker, you need to understand psychology. What makes people trust an email? How can you impersonate IT support convincingly? Maybe you’re joining together an employee’s habits from their LinkedIn posts. It’s not just coding it’s manipulation, and it’s disturbingly effective.Staying Hidden: The Real SkillAPT hackers don’t seek fame they seek results.Ever heard of “living off the land”? It’s when hackers use built-in system tools like PowerShell or WMI so their activity doesn’t trigger alarms. In the 2017 Equifax breach, attackers exploited a known vulnerability but avoided detection by blending in with normal admin activity. No flashy malware, just quiet destruction.Want to stay invisible? Learn how to:  Encrypt your payloads.  Spoof IP addresses with VPNs or TOR.  Pivot through compromised IoT devices to mask your origin.  The best hackers make it look like they were never there at all.The Dark Side: Ethics and ConsequencesHere’s where things get real. APT hacking isn’t a game. These skills are used by cybersecurity researchers and ethical hackers—but they’re also used by nation-states and cybercriminals.Stealing data, disrupting infrastructure, or manipulating global markets isn’t just “hacking”, it’s warfare. One wrong move, and you could end up on a government watchlist or in federal custody. Know the risks before you go too deep.So, You Still Want In?Being an APT hacker isn’t about quick wins. It’s about discipline, patience, and an obsession with detail. If you’re serious, start small:  Set up a virtual lab.  Play  CTF’s on Hack The Box.  Study real-world APT attacks (APT28, Lazarus Group, etc.).But remember: once you step into this world, there’s no turning back!What’s your next move?"
  }
  
]

